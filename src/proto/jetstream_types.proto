package jetstream;

//option optimize_for = LITE_RUNTIME;  // Messages become MessageLite-s


/**
* Identifies a single node (host).
* Bytes should be an IP4 or IP6 address
*/
message NodeID {
  required bytes address = 1;
  required int32 portno = 2;
}


/**
* The ID of a task (aka operator). The computationID is globally unique within a
* particular JetStream cluster and identifies the computation or topology to which 
* this task belongs. The task field is unique within a computation.
*/
message TaskID {
  required int32 computationID = 1;
  required int32 task = 2;
}


message Element {
  // Keep this type consistent with the optional fields below
  enum ElementType {STRING = 1; INT32 = 2; DOUBLE = 3; TIME=4;}
  optional string s_val = 1;
  optional int32 i_val = 2;
  optional double d_val = 3;
  optional int32 t_val = 4;
}


message Dimension {
  required string name = 1;
  required Element.ElementType type = 2;
  optional Element default_val = 3;
}


/**
* Metadata of a task (aka operator). When used solely to identify the task, only the
* id field needs to be specified.
*/
message TaskMeta {
  required TaskID id = 2;           // uniquely identifies the operator
  required string op_typename = 1;  // type of operator, typically a classname
                                    // (note that 'typename' is a C++ keyword.
  optional NodeID site = 3;

  message DictEntry {
    required string opt_name = 1;
    required string val = 2;
  }
  repeated DictEntry config = 4;    // list of key-value pairs. 

  //TODO: Determine minimal set of attributes client must specify for submitted operators.
  // optional int32 partialAggRatio
  // optional boolean isUnion
}


message CubeSchema{
  required string name = 1;    // uniquely identifies the cube

  message Dimension {
    required string name = 1;
    required Element.ElementType type = 2;
  }
  repeated Dimension dimensions = 2;

  message Aggregate {
    required string name = 1;
    required string type = 2;  // class name of aggregate type
  }
  repeated Aggregate aggregates = 3;
}


/**
* Metadata of a cube. When used solely to identify the cube, only the name field needs
* to be specified.
*/
message CubeMeta {
  required string name = 1;
  required CubeSchema schema = 2;
  optional NodeID site = 3;
  
  optional bool overwrite_old = 4 [default = false];  
    // If overwrite_old set to true, cube will be emptied on create; schema will
    // be changed if table already existed. If set to false, schema will not be
    // changed. Create will succeed only if existing table has same schema.
}


message Tuple {
 repeated Element e = 1;
}


/**
* A connection between two points in the computation graph.
* Operators must be in the same computation.
* Cubes are globally visible and are NOT tied to a computation.
*/
message Edge {
  required int32 src = 1;          // operator ID, local
  required int32 computation = 4;  // which computation the edge is in

  optional int32 dest = 2;         // operator ID, local
  optional string cube_name = 3;   // cube name, local or remote
  optional NodeID dest_addr = 5;   // dest address if remote
}


/**
* An AlterTopo specifies a set of mutations to the operator graph of a single
* computation. 
*
* When used as a request, it includes operators and cubes to start, operators and
* cubes to stop, and edges to add. Since cubes are shared across computations, care 
* must be taken when starting/stopping them (but the directive should still be
* associated with a computation ID). 
* 
* When used as a response, the AlterTopo message indicates which operators and cubes
* were successfully started/stopped.
*/
message AlterTopo {
  // Use one computation ID per message
  required int32 computationID = 1;

  repeated TaskMeta toStart = 2;
  repeated CubeMeta toCreate = 3;
  repeated TaskID taskToStop = 4; 
  repeated string cubesToStop = 5; 
  repeated Edge edges = 6;
}


/***
* A heartbeat is a kind of message from the data plane to the coordinator server.
*/
message Heartbeat {
  //SS: Consider including an explicit nodeID, in case heartbeats are aggregated/forwarded.
  //required NodeID nodeId = 16;
  required int32 freemem_mb = 17;   // MB of free mem on node
  required int32 cpuload_pct = 18;  // percentage of CPU resources that's free
}


message Error {
 required string msg = 1;
}


/*** 
* A message between controller and workers, or from client to controller.
* The fields of the message should line up with the type field. This is a human
* notational convenience, and not enforced or used in the code.
*/
message ControlMessage {
  enum ControlType { ERROR = 2; HEARTBEAT = 3; GET_NODE_LIST_REQ = 4; NODE_COUNT_REQ = 5; 
                     ALTER = 6; ALTER_RESPONSE = 7; NODES_RESPONSE = 8; OK = 9; }
  required ControlType type = 1; 
  
  optional Error error_msg = 2;
  optional Heartbeat heartbeat = 3;
  optional int32 node_count = 5;
  optional AlterTopo alter = 6; 
  repeated NodeID nodes = 7;
   
}


/***
* "dataplane" message, from worker to worker.
* The fields of the message should line up with the type field. This is a human
* notational convenience, and not enforced or used in the code.
*/ 
message DataplaneMessage {
  enum DataplaneType { ERROR = 2; DATA = 3; CHAIN_CONNECT = 4; CHAIN_READY = 5; }
  required DataplaneType type  = 1;

  optional Error error_msg = 2;
  optional Edge chain_link = 3;
  repeated Tuple data = 4;  // Streaming data on the data plane
}
